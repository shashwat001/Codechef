#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <vector>
#include <utility>
#include <queue>
#include <stack>
#include <list>
#include <algorithm>

using namespace std;

#define INF 2147483647
#define LLINF 9223372036854775807
#define mp make_pair
#define pb push_back

typedef long long int lli;
typedef unsigned int uint;
typedef unsigned long long int ulli;
typedef pair<int,int> pairint;

#define BUF 4096
char ibuf[BUF];
int ipt = BUF;

int readInt()
{
	while (ipt < BUF && ibuf[ipt] < '0')
		ipt++;

	if (ipt == BUF)
	{
		fread(ibuf, 1, BUF, stdin);
		ipt = 0;
		while (ipt < BUF && ibuf[ipt] < '0')
			ipt++;
	}

	int n = 0;
	while (ipt < BUF && ibuf[ipt] >= '0')
		n = (n*10)+(ibuf[ipt++]-'0');

	if (ipt == BUF)
	{
		fread(ibuf, 1, BUF, stdin);
		ipt = 0;
		while (ipt < BUF && ibuf[ipt] >= '0')
			n = (n*10)+(ibuf[ipt++]-'0');
	}
	return n;
}

/********************************************************************************************/

int i,j;
//pair<pairint,pairint > nr[8000010];
//int con[20][400010];
/*bool comp(const pair<pairint,pairint > x,const pair<pairint,pairint > y)
{
	if(x.first.first < y.first.first)
		return true;
	else if(x.first.first == y.first.first)
	{
		if(x.first.second <= y.first.second)
			return true;
	}
	return false;
}
*/
int temp[2][400010];
#define MOD 1000000007



int modmulinverse(int a,int m)
{
    int x = 0,y = 1,u = 1,v = 0; 
    int e = m,f = a;
    int c,d,q,r;
    while(f != 1)
    {
        q = e/f;
        r = e%f;
        c = x-q*u;
        d = y-q*v;
        x = u;
        y = v;
        u = c;
        v = d;
        e = f;
        f = r;
    } 
    return u%m;
}



pair<int, pair<int, int> > extendedEuclid(int a, int b)
{
	    int x = 1, y = 0;
	    int xLast = 0, yLast = 1;
	    int q, r, m, n;
	    while(a != 0) {
	        q = b / a;
	        r = b % a;
	        m = xLast - q * x;
	        n = yLast - q * y;
	        xLast = x, yLast = y;
	        x = m, y = n;
	        b = a, a = r;
	    }
	    return make_pair(b, make_pair(xLast, yLast));
	}
	 
	lli modInverse(int a, int m) {
		lli out = (extendedEuclid(a,m).second.first + m)%m;
	    return out;
	}

int main()
{
    int r,n,m,a,b,cnr = 0;
	lli sum,k,l;
	r = readInt();
	for(i = 0;i <r;i++)
	{
		//scanf("%d %d %d %d",&n,&m,&a,&b);
		n = readInt();
		m = readInt();
		a = readInt();
		b = readInt();
		k = 1;
		for(j = 1;j < b;j++)
		{
			l = ((n-a+j)*modInverse(j,MOD))%MOD;
			k = (k*l)%MOD;
			
		}
		for(;j <= m;j++)
		{
			l = ((n-a+j)*modInverse(j,MOD))%MOD;
			k = (k*l)%MOD;
			temp[0][m-j] = k;
		}
		k = 1;
		temp[1][0] = 1;
		sum = temp[0][0];
		for(j = 1;j <= m-b;j++)
		{
			l = ((a-1+j)*modInverse(j,MOD))%MOD;
			k = (k*l)%MOD;
			temp[1][j] = k;
			l = ((lli)temp[0][j]*(lli)temp[1][j]);
			l = l%MOD;
			sum=(sum+l)%MOD;
		}
		printf("%lld\n",sum);
	}
	/*sort(nr,nr+cnr,comp);
	int cr=0;
	while((nr[cr].first.first == 0) && (nr[cr].first.second == 0))
	{
		con[nr[cr].second.first][nr[cr].second.second] = 1;
		cr++;
	}
	for(i = 1;i <= nr[cnr-1].first.first;i++)
	{
	  temp[1][0] = temp[1][i] = 1;
	  for(j = 1;j < i;j++)
	  {
	    temp[1][j] = (temp[0][j-1] + temp[0][j])%MOD;
	  }
	  for(j = 0;j <= i;j++)
	  {
	    temp[0][j] = temp[1][j];
	    while((i == nr[cr].first.first) && (j == nr[cr].first.second))
	    {
	      con[nr[cr].second.first][nr[cr].second.second] = temp[0][j];
		  cr++;
	    }
	  }
	}
	for(i = 0;i <r;i++)
	{
		lli sum = 0;
		for(j = 0;j <= m[i]-b[i];j++)
		{
		      sum+=(con[i][j] * con[i+10][j])%MOD;
		}
		printf("%lld\n",sum);
	}*/
	return 0;
}